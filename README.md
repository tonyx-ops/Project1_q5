# Project1_q5
# Experimental Analysis of q5 Algorithm

This project analyzes the runtime complexity of a pseudocode algorithm where `j` grows by √3 and `k` grows by √2. Theoretical analysis suggests that the runtime is Θ((log n)²). To verify this hypothesis, we implement the algorithm in Python, measure runtimes for different input sizes, normalize the data against the theoretical function, and generate plots for comparison.

To run this project, you need Python 3.8 or higher with the following packages installed: numpy, pandas, and matplotlib. You can install them with `pip install numpy pandas matplotlib`. The repository contains one main script, `exp_analysis_simple.py`, which implements the algorithm, measures runtimes across a range of input sizes, computes the theoretical (log n)² values, normalizes theory to match experimental results using single-point scaling, and exports results as both a CSV file and plots. The script automatically creates an `outputs/` folder that stores `experimental_vs_theory.csv`, `plot_exp_vs_theory.png`, and `plot_ratio.png`.

To run the analysis from the command line, execute `python exp_analysis_simple.py` in your terminal, and the results will be generated inside the `outputs/` folder. If you prefer interactive exploration, you can use Jupyter Notebook by running `jupyter notebook`, creating a new Python 3 notebook, and copying the code from `exp_analysis_simple.py` into cells to run step by step.

The script can be customized in several ways. By default, it tests input sizes `n` from 1024 to 131072 using powers of two. You can edit the `N_VALUES` list to include larger or custom sizes, such as values up to 1 million for smoother plots. The number of timing repeats per input size can be adjusted by changing the `REPEATS` variable (increasing gives more stable results but takes longer). By default, runtime is reported in seconds, but you can switch to nanoseconds by multiplying elapsed times by 1e9 in the timing function. The arrays `a` and `b` can also be defined with fixed values (e.g., all 1’s) instead of random numbers to ensure results.

The output consists of both a CSV file and plots. The CSV contains columns for input size, experimental runtimes, theoretical (log n)² values, normalized theoretical values, and ratios. The plots include a comparison of experimental vs normalized theoretical runtimes, and a ratio plot showing experimental results relative to theory. These outputs confirm whether the experimental data supports the theoretical Θ((log n)²) complexity. In practice, the curves align closely for large n, validating the hypothesis, although small input sizes may show divergence due to constant overheads.

In summary, this project provides both theoretical and experimental validation of the given pseudocode’s time complexity. It demonstrates how to normalize runtime data to theoretical models and includes clear outputs in both numerical and graphical form. While runtime results may vary slightly depending on hardware, the methodology and normalization ensure that the asymptotic behavior is clearly visible and consistent with Θ((log n)²).
